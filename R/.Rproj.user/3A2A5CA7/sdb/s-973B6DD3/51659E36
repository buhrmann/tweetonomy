{
    "contents" : "library(igraph)\nlibrary(tcltk)\nlibrary(rgl)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\n\n# --------------------------------------------------------------------------------\n# Basic stats\n# --------------------------------------------------------------------------------\ncomponent_sizes = function(graph, mode=\"weak\") {\n  comps = components(graph, mode)\n  table(comps$csize)\n}\n\nkcore_dist = function(graph) {\n  vcoreness = coreness(graph)\n  table(vcoreness)\n}\n\nweight_dist = function(graph) {\n  table(E(graph)$weight)\n}\n\ncentrality_names = list(\"degree\", \"between\", \"eigen\", \"close\", \"auth\", \"hub\", \"pgrank\")\n\ncentrality = function(graph, centrality='eigen', norm=T) {\n  switch(centrality,\n         degree = degree(graph, mode='all', normalized=norm),\n         between = betweenness(graph, normalized=norm), \n         eigen = eigen_centrality(graph, directed=T, scale=norm)$vector,\n         close = closeness(graph, mode='all'),\n         auth = authority_score(graph, scale=norm)$vector,\n         hub = hub_score(graph)$vector,\n         pgrank = page_rank(graph)$vector \n         )\n}\n\ncentralities = function(graph, norm=TRUE, plot=FALSE) {\n  cents = lapply(centrality_names, FUN=centrality, graph=graph, norm=norm)\n  cents = as.data.frame(do.call(cbind, cents))\n  colnames(cents) = centrality_names\n  \n  # Drew Conway: high bet and low eig vs. low bet and high eig...\n  cents$res = abs(lm(eigen~between, data=cents)$residuals)\n  if (plot) {\n    cents$names = rownames(cents)\n    ggplot(cents, aes(x=bet, y=eig, color=res, label=names, size=abs(res))) + \n      geom_text() +\n      xlab(\"Betweenness\") + ylab(\"EV\")\n  }\n  return(cents)\n}\n\n\ntopn_by_centrality = function(graph, centrality=\"eigen\", topn=5) {\n  cent = centrality(graph, centrality, norm=F)\n  topi = order(cent, decreasing=T)[1:topn]\n  return(names(cent)[topi])\n}\n\n\n# Assumes graph has as a \"com\" vertex attribute (membership), and a\n# communities object as graph attribute\n# Return named list of actors per community, labelled by community index\n# For flat list, unlist(result)\nimportant_actors_by_com = function(graph, topn=2, centrality='res') {\n  com_ids = unique(V(graph)$com)\n  sel_coms = graph$communities[com_ids]\n  group_acts = list()\n  for (i in 1:length(sel_coms)) {\n    com_name = names(sel_coms)[i]\n    com_verts = V(h)[sel_coms[[com_name]]]  \n    sub = induced_subgraph(graph, com_verts)  \n    group_acts[[com_name]] = topn_by_centrality(sub, centrality, topn)\n    remove(sub)\n  }\n  return(group_acts)\n}\n\n# --------------------------------------------------------------------------------\n# Calculate extra features\n# --------------------------------------------------------------------------------\ng_plot = function(graph, layout=NULL, colorAttr=NULL, mode='r', emph_ids=NULL, groups=list()) {\n  \n  # Create layout\n  if (is.null(layout)) {\n    layout = with_fr(niter=1000)    \n  }\n  graph = add_layout_(graph, layout, component_wise(merge_method=\"dla\"))\n  \n  # Add vertex colors\n  if (is.null(colorAttr)) {\n    if (\"com\" %in% list.vertex.attributes(graph)) {\n      colorAttr = \"com\" } \n  }\n  \n  if (!is.null(colorAttr) && colorAttr %in% list.vertex.attributes(graph)) {\n    graph = add_color_by_attribute(graph, colorAttr)\n  } else {\n    V(graph)$color = \"black\"\n  }\n  \n  w_max = max(E(graph)$weight)\n  ewidth = 5*E(graph)$weight/w_max\n  vsize = 0.5+1.5*log10(degree(graph))\n  vlfamily = \"sans\"\n  vlcex = 0.75\n  vldeg = 0\n  vldist = 0.0\n  \n  # highlight vertices\n  V(graph)$vertex.frame.color = NA\n  if (is.vector(emph_ids)) {\n    vsize[emph_ids] = vsize[emph_ids] * 2    \n    #V(graph)$vertex.frame.color = NA\n    V(graph)[emph_ids]$vertex.frame.color = \"black\"\n  }\n  \n  if (\"label\" %in% list.vertex.attributes(graph)){\n    labels = V(graph)$label\n  } else {\n    labels = NA\n  }\n  \n  args = list(graph, \n              vertex.label=labels,\n              vertex.size=vsize, vertex.label.color=\"black\",\n              vertex.frame.color=V(graph)$vertex.frame.color,\n              vertex.label.family=vlfamily, vertex.label.cex=vlcex, \n              vertex.label.degree=vldeg, vertex.label.dist=vldist,\n              edge.width=ewidth, edge.arrow.size=0, edge.arrow.width=0, \n              asp=0, margin=-0.1,\n              mark.groups=groups)\n  \n  if (mode == 'r') {\n    do.call(plot, args)\n  } else if (mode == 'tk') {\n    tkid = do.call(tkplot, args)\n    canvas = tk_canvas(tkid)\n    tkconfigure(canvas, \"bg\"=\"white\")\n  } else if (mode == 'gl') {\n    rgl.open()\n    rgl.bg(color=\"white\", alpha=c(.3), back=\"fill\", sphere = FALSE, fogtype = \"none\", line_antialias = TRUE)\n    rgl.viewpoint(0, 0, fov=100, zoom=.5)\n    rgl.material(lit=FALSE, shininess=0)\n    rgl.pop(\"lights\")\n    light3d(specular=\"black\")\n    do.call(rglplot, args)\n  }\n  \n  return(graph)\n}\n\n# --------------------------------------------------------------------------------\n# Calculate extra features\n# --------------------------------------------------------------------------------\nadd_color_by_attribute = function(graph, attrib) {\n  a = get.vertex.attribute(graph, attrib)\n  com_fac = as.factor(a)\n  num_facs = length(unique(levels(com_fac)))\n  #palette = rainbow(num_facs)\n  palette = brewer.pal(num_facs, \"Set3\")\n  V(graph)$color = as.character(lapply(com_fac, function(x) { palette[x] }))\n  edge.start = get.edges(graph, 1:ecount(graph))[,1]\n  E(graph)$color = V(graph)$color[edge.start]\n  return(graph)\n}\n\nadd_importance = function(graph) {\n  act = important_actors(h)\n  V(graph)$importance = abs(act$res)\n  return(graph)\n}\n\n\n# --------------------------------------------------------------------------------\n# Modify weights to reflect community structure\n# https://stackoverflow.com/questions/16390221/how-to-make-grouped-layout-in-igraph\n# --------------------------------------------------------------------------------\nedge_weight_community = function(row, membership, weigth.within, weight.between) {\n  if(as.numeric(membership[which(names(membership)==row[1])])==as.numeric(membership[which(names(membership)==row[2])])){\n    return(weigth.within)\n  }else{\n    return(weight.between)\n  }\n}\n\nreweight_by_community = function(graph, within, between) {\n  G = graph\n  E(G)$weight = apply(get.edgelist(G), 1, edge_weight_community, membership(graph$communities), within, between)\n  return(G)\n}\n\n\n# --------------------------------------------------------------------------------\n# Wrapper for community detection algos\n# http://bommaritollc.com/2012/06/summary-community-detection-algorithms-igraph-0-6/\n# --------------------------------------------------------------------------------\nfind_communities = function(graph, algo, weights=NULL) {\n  if (is.null(weights)) {\n    weights = E(graph)$weight\n  }\n  \n  if (algo == 'walktrap') {\n    return (cluster_walktrap(graph, weights=weights))\n  } else if (algo == 'edge_betweenness') {\n    return (cluster_edge_betweenness(graph, weights=weights))\n  } else if (algo == 'fast_greedy') {\n    gu = as.undirected(graph, mode=\"collapse\", edge.attr.comb=list(weight=\"sum\"))\n    return (cluster_fast_greedy(gu, weights=E(gu)$weights))\n  } else if (algo == 'spinglass') {\n    return (cluster_spinglass(graph, weights=weights))\n  } else if (algo == 'leading_eigen') {\n    return (cluster_leading_eigen(graph, weights=weights))\n  } else if (algo == 'optimal') {\n    return (cluster_optimal(graph, weights=weights))\n  } else if (algo == 'louvain') {\n    return (cluster_louvain(graph, weights=weights))\n  } else if (algo == 'label_prop') {\n    return (cluster_label_prop(graph, weights=weights))\n  } else if (algo == 'infomap') {\n    return (cluster_infomap(graph, e.weights=weights))\n  }\n}\n\ncommunity_containing = function(graph, nodename) {\n  com_ids = unique(V(graph)$com)\n  for (i in 1:length(com_ids)) {\n    com_id = com_ids[i]\n    if (nodename %in% graph$communities[[com_id]]) {\n      return(com_id)\n    }\n  }\n  return(-1)\n}\n\n# --------------------------------------------------------------------------------\n# Graph filters\n# --------------------------------------------------------------------------------\n\n# Only large communities\n# --------------------------------------------------------------------------------\nfilter_topn_communities = function(graph, n, algo=\"fast_greedy\", coms=NULL) {\n  if(is.null(coms)){\n    graph$communities = find_communities(graph, algo)\n    V(graph)$com = membership(graph$communities)\n  }\n  top_coms = names(sort(sizes(graph$communities), decreasing=T)[1:n])\n  excl_verts = !(membership(graph$communities) %in% top_coms)\n  return(delete.vertices(graph, excl_verts))\n}\n\nfilter_min_community_size = function(graph, min_size, algo=\"fast_greedy\", coms=NULL) {\n  if(is.null(coms)){\n    graph$communities = find_communities(graph, algo)\n    V(graph)$com = membership(graph$communities)\n  }\n  com_sizes = sizes(graph$communities)\n  big_coms = names(com_sizes[com_sizes >= min_size])\n  excl_verts = !(membership(graph$communities) %in% big_coms)\n  return(delete.vertices(graph, excl_verts))\n}\n\n# Maximal subgraph in which each vertex has at least degree k\nfilter_min_coreness = function(graph, min_coreness=3) {\n  vcoreness = coreness(graph, mode=\"all\")\n  kcore = induced_subgraph(graph, as.vector(which(vcoreness >= min_coreness)))\n  return(kcore)\n}\n\n# Connected components\n# https://lists.nongnu.org/archive/html/igraph-help/2011-08/msg00000.html\nfilter_small_components = function(graph, min_size=3, mode=\"weak\") {\n  comps = components(graph, mode)\n  small_components = which(comps$csize < min_size)\n  excl_verts = which(comps$membership %in% small_components)\n  return(delete.vertices(graph, excl_verts))\n}\n\nfilter_topn_components = function(graph, topn=1, mode=\"weak\") {\n  comps = components(graph, mode)\n  topi = order(comps$csize, decreasing=T)[1:topn]\n  incl_verts = which(comps$membership %in% topi)\n  return(induced_subgraph(graph, incl_verts))\n}\n\nfilter_isolates = function(graph) {\n  return(delete.vertices(graph, which(degree(graph) == 0))) \n}\n\n# --------------------------------------------------------------------------------\n# Layouts that reflect community structure\n# --------------------------------------------------------------------------------\n\n# https://stackoverflow.com/questions/28715736/how-to-spread-out-community-graph-made-by-using-igraph-package-in-r\n# --------------------------------------------------------------------------------\nlayout.by.attr = function(graph, wc, cluster.strength=1,layout=layout.auto) {  \n  g = graph.edgelist(get.edgelist(graph)) # create a lightweight copy of graph w/o the attributes.\n  E(g)$weight = 1  \n  attr = cbind(id=1:vcount(g), val=wc)\n  g = g + vertices(unique(attr[,2])) + igraph::edges(unlist(t(attr)), weight=cluster.strength)  \n  l = layout(g, weights=E(g)$weight)[1:vcount(graph),]\n  return(l)\n}\n\n# https://stackoverflow.com/questions/16390221/how-to-make-grouped-layout-in-igraph\n# --------------------------------------------------------------------------------\nlayout.modular = function(G, c) {\n  G$layout = layout.fruchterman.reingold(G) # Fill with something so not NULL\n  nm = length(levels(as.factor(c$membership)))\n  gr = 2\n  while(gr^2 < nm) {\n    gr = gr + 1\n  }\n  \n  i = j = 0\n  for(cc in levels(as.factor(c$membership))) {\n    F = delete.vertices(G, c$membership != cc)\n    F$layout = layout.kamada.kawai(F)\n    F$layout = layout.norm(F$layout, i, i+0.5, j, j+0.5)\n    G$layout[c$membership==cc,] = F$layout\n    if(i==gr){\n      i = 0\n      if(j==gr){\n        j = 0\n      }else{\n        j = j+1\n      }\n    }else{\n      i = i+1\n    }\n  }\n  return(G$layout)\n}\n\n# --------------------------------------------------------------------------------\n# Print basic stats\n# --------------------------------------------------------------------------------\nprint_stats = function(g) {\n  component_sizes(g, \"weak\")\n  kcore_dist(g)\n  vcount(g)\n  ecount(g)\n}\n\n# communities\ncoms = find_communities(g, 'fast_greedy')\nhead(sort(sizes(coms), decreasing=T), 25)\n",
    "created" : 1437993286532.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3255143582",
    "id" : "51659E36",
    "lastKnownWriteTime" : 1438791154,
    "path" : "~/Code/tweetonomy/R/utils.R",
    "project_path" : "utils.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}